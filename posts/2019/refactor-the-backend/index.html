<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>代码重构 - 后端部分代码 | TechNotes</title>
<meta name=keywords content="重构,设计模式">
<meta name=description content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。
在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。
代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。
原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。
1 2 3  postVue(&#34;${ctx}/BusinessOpportunity/openAcct&#34;,params,function (data) {...... postVue(&#34;${ctx}/BusinessOpportunity/openAmlInviteAcct&#34;,params,function (data) {......   这里是原有的Controller的实现： 然后则是Service的实现：
然后就是Service调用不同的MyBatis的dao层实现。
从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。
重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：
 尽可能的代码复用 为使用方提供一致的调用外观  所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。
由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。
这个是REST Controller的实现：
@PostMapping(&#34;/api/opportunities/batch&#34;) public ResponseEntity<?> batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(&#34;Process opportunity batch action - type: {}&#34;, request.getType()); List<String> emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(&#34;Process opportunity batch action failed, type: {}, root cause: {}&#34;, request.">
<meta name=author content="TechNotes">
<link rel=canonical href=https://technotes.guru/posts/2019/refactor-the-backend/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.030f3f25d9f3449b524f810ddd2c31b9d4718215f17a58bacbd906ecaf639910.css integrity="sha256-Aw8/JdnzRJtST4EN3SwxudRxghXxeli6y9kG7K9jmRA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://technotes.guru/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://technotes.guru/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://technotes.guru/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://technotes.guru/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://technotes.guru/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.0">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="代码重构 - 后端部分代码">
<meta property="og:description" content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。
在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。
代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。
原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。
1 2 3  postVue(&#34;${ctx}/BusinessOpportunity/openAcct&#34;,params,function (data) {...... postVue(&#34;${ctx}/BusinessOpportunity/openAmlInviteAcct&#34;,params,function (data) {......   这里是原有的Controller的实现： 然后则是Service的实现：
然后就是Service调用不同的MyBatis的dao层实现。
从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。
重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：
 尽可能的代码复用 为使用方提供一致的调用外观  所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。
由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。
这个是REST Controller的实现：
@PostMapping(&#34;/api/opportunities/batch&#34;) public ResponseEntity<?> batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(&#34;Process opportunity batch action - type: {}&#34;, request.getType()); List<String> emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(&#34;Process opportunity batch action failed, type: {}, root cause: {}&#34;, request.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://technotes.guru/posts/2019/refactor-the-backend/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-02-28T00:00:00+00:00">
<meta property="article:modified_time" content="2019-02-28T00:00:00+00:00"><meta property="og:site_name" content="TechNotes">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="代码重构 - 后端部分代码">
<meta name=twitter:description content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。
在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。
代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。
原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。
1 2 3  postVue(&#34;${ctx}/BusinessOpportunity/openAcct&#34;,params,function (data) {...... postVue(&#34;${ctx}/BusinessOpportunity/openAmlInviteAcct&#34;,params,function (data) {......   这里是原有的Controller的实现： 然后则是Service的实现：
然后就是Service调用不同的MyBatis的dao层实现。
从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。
重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：
 尽可能的代码复用 为使用方提供一致的调用外观  所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。
由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。
这个是REST Controller的实现：
@PostMapping(&#34;/api/opportunities/batch&#34;) public ResponseEntity<?> batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(&#34;Process opportunity batch action - type: {}&#34;, request.getType()); List<String> emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(&#34;Process opportunity batch action failed, type: {}, root cause: {}&#34;, request.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://technotes.guru/posts/"},{"@type":"ListItem","position":2,"name":"代码重构 - 后端部分代码","item":"https://technotes.guru/posts/2019/refactor-the-backend/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"代码重构 - 后端部分代码","name":"代码重构 - 后端部分代码","description":"前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。\n在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。\n代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。\n原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。\n1 2 3  postVue(\u0026#34;${ctx}/BusinessOpportunity/openAcct\u0026#34;,params,function (data) {...... postVue(\u0026#34;${ctx}/BusinessOpportunity/openAmlInviteAcct\u0026#34;,params,function (data) {......   这里是原有的Controller的实现： 然后则是Service的实现：\n然后就是Service调用不同的MyBatis的dao层实现。\n从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。\n重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：\n 尽可能的代码复用 为使用方提供一致的调用外观  所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。\n由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。\n这个是REST Controller的实现：\n@PostMapping(\u0026quot;/api/opportunities/batch\u0026quot;) public ResponseEntity\u0026lt;?\u0026gt; batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(\u0026quot;Process opportunity batch action - type: {}\u0026quot;, request.getType()); List\u0026lt;String\u0026gt; emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(\u0026quot;Process opportunity batch action failed, type: {}, root cause: {}\u0026quot;, request.","keywords":["重构","设计模式"],"articleBody":" 前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。\n在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。\n代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。\n原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。\n1 2 3  postVue(\"${ctx}/BusinessOpportunity/openAcct\",params,function (data) {...... postVue(\"${ctx}/BusinessOpportunity/openAmlInviteAcct\",params,function (data) {......   这里是原有的Controller的实现： 然后则是Service的实现：\n然后就是Service调用不同的MyBatis的dao层实现。\n从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。\n重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：\n 尽可能的代码复用 为使用方提供一致的调用外观  所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。\n由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。\n这个是REST Controller的实现：\n@PostMapping(\"/api/opportunities/batch\") public ResponseEntity batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(\"Process opportunity batch action - type: {}\", request.getType()); List emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(\"Process opportunity batch action failed, type: {}, root cause: {}\", request.getType(), e); return WebUtil.error(e.getMessage()); } String message = \"保存成功,以下企业发送通知失败，请检查：\" + String.join(\", \", emailSendFailedList); return new ResponseEntity(RestResponse.builder().status(HttpStatus.OK.value()).body(Boolean.TRUE).message(message).build(), HttpStatus.OK); } /api/opportunities 这部分其实是放RestController类注解上的，这里只是为了说明。 另外，按照REST语义，针对不同的资源的操作，是区分GET、POST、DELETE等动词的，但是在真实的项目环境下，其实很难严格按照REST语义的，所以这里针对批处理的方式，统一使用了POST。\n这个是RequestBody的部分，作为数据(schema)，type表述执行什么操作，data则是本次操作的数据部分。\n@Data @ToString public class OpportunityBatchRequest { private String type; private List data; @Data public static class RequestData { private String companyName; private String contactNumber; private Integer customerId; private String email; private String opportunityId; } } 这部分就是针对批处理操作的Controller层，下面则是Service层，由于在上面已经给出了UML类图，所以这里主要是给出一些具体的实现：\n首先是定义接口，用以规范行为，这边的泛型其实并没有实际的意义，直接就是OpportunityBatchRequest 这个类\npublic interface OpportunityProcessor { boolean supports(String type); void process(T request) throws ProcessException; } 主要是两个方法：\n supports：用以在具体的实现类中表达支持哪种type的处理 process： 业务处理方法  具体的子类的实现示例如下：\n/** * 开通反洗钱 */ @Service @Slf4j public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor { private static final String SUPPORTS_TYPE = \"OpenAmlAccount\"; @Override public boolean supports(String type) { return SUPPORTS_TYPE.equalsIgnoreCase(type); } @Override public void process(OpportunityBatchRequest request) throws ProcessException { log.info(\"Process OpenAmlAccount action\"); } } /** * 开通反洗钱邀请 */ @Service @Slf4j public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor { private static final String SUPPORTS_TYPE = \"OpenAmlInviteAccount\"; @Override public boolean supports(String type) { return SUPPORTS_TYPE.equalsIgnoreCase(type); } @Override public void process(OpportunityBatchRequest request) throws ProcessException { log.info(\"Process OpenAmlInviteAccount action\"); } } 这里的抽象父类AbstractOpportunityProcessor，用以处理一些较为公共的逻辑等，比如注入公共组件，抽些公共的方法等。引入这个抽象类的性价比是很高的。\n重构后的代码 这个例子中，有几个操作都是开通账号、邀请相关的，所以，涉及开通账号方法，就可以放在这个抽象父类中，而相应的子类，则只需要说明账户类型，就可以了：\n/** * 开通反洗钱 */ @Service @Slf4j public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor { private static final String SUPPORTS_TYPE = \"OpenAmlAccount\"; private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.AML; @Override public boolean supports(String type) { return SUPPORTS_TYPE.equalsIgnoreCase(type); } @Override public void process(OpportunityBatchRequest request) throws ProcessException { log.info(\"Process OpenAmlAccount action\"); for (OpportunityBatchRequest.RequestData requestData : request.getData()) { openAccount(requestData, ACCOUNT_OPEN_MODE); } } } /** * 开通反洗钱邀请 */ @Service @Slf4j public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor { private static final String SUPPORTS_TYPE = \"OpenAmlInviteAccount\"; private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.INVITE_AML; @Override public boolean supports(String type) { return SUPPORTS_TYPE.equalsIgnoreCase(type); } @Override public void process(OpportunityBatchRequest request) throws ProcessException { log.info(\"Process OpenAmlInviteAccount action\"); for (OpportunityBatchRequest.RequestData requestData : request.getData()) { openAccount(requestData, ACCOUNT_OPEN_MODE); } } } 而对于其他的操作，则只需要在具体自己的子类中实现，如删除:\n/** * 批量删除 */ @Service @Slf4j public class DeleteOpportunitiesProcessor extends AbstractOpportunityProcessor { private static final String SUPPORTS_TYPE = \"DeleteOpportunities\"; @Override public boolean supports(String type) { return SUPPORTS_TYPE.equalsIgnoreCase(type); } @Override public void process(OpportunityBatchRequest request) throws ProcessException { log.info(\"Process DeleteOpportunities action\"); List opportunityIdList = request.getData() .stream() .map(OpportunityBatchRequest.RequestData::getOpportunityId) .collect(Collectors.toList()); businessOpportunityMapper.deleteOpportunitiesInBatch(opportunityIdList); } } 后记 这是本次重构的后端部分，相应的套路（模式）也更多一些，自己也相对的更加熟悉一些。这两篇博客提到的模式，在很多场景下都可以使用。\n谢谢阅读。\nWorks，then better.\n(2019-02-28 发表于简书)\n","wordCount":"403","inLanguage":"en","datePublished":"2019-02-28T00:00:00Z","dateModified":"2019-02-28T00:00:00Z","author":{"@type":"Person","name":"TechNotes"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://technotes.guru/posts/2019/refactor-the-backend/"},"publisher":{"@type":"Organization","name":"TechNotes","logo":{"@type":"ImageObject","url":"https://technotes.guru/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://technotes.guru/ accesskey=h title="TechNotes (Alt + H)">TechNotes</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://technotes.guru/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=https://technotes.guru/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://technotes.guru/about/ title=about>
<span>about</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://technotes.guru/>Home</a>&nbsp;»&nbsp;<a href=https://technotes.guru/posts/>Posts</a></div>
<h1 class=post-title>
代码重构 - 后端部分代码
</h1>
<div class=post-meta>2019-02-02&nbsp;·&nbsp;2 min&nbsp;·&nbsp;TechNotes
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label=代码实现>代码实现</a><ul>
<li>
<a href=#%e5%8e%9f%e6%9d%a5%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=原来的实现>原来的实现</a></li>
<li>
<a href=#%e9%87%8d%e6%9e%84%e8%bf%87%e7%a8%8b aria-label=重构过程>重构过程</a></li>
<li>
<a href=#%e9%87%8d%e6%9e%84%e5%90%8e%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=重构后的代码>重构后的代码</a></li></ul>
</li>
<li>
<a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>
<a href=https://technotes.guru/posts/2019/refactor-the-frontend/>
前一篇
</a>主要写了一下前端部分的重构，这一篇则主要关注后端部分。</p>
<p>在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示：
<img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203814.png alt>
</p>
<p>在后端部分，我先将后端Java代码的类图画出来：
<img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203838.png alt>
</p>
<p>可以发现，还是一样的套路。</p>
<h2 id=代码实现>代码实现<a hidden class=anchor aria-hidden=true href=#代码实现>#</a></h2>
<p>下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。</p>
<h3 id=原来的实现>原来的实现<a hidden class=anchor aria-hidden=true href=#原来的实现>#</a></h3>
<p>在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过<code>POST</code>请求调用后端的Controller。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=nx>postVue</span><span class=p>(</span><span class=s2>&#34;${ctx}/BusinessOpportunity/openAcct&#34;</span><span class=p>,</span><span class=nx>params</span><span class=p>,</span><span class=kd>function</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{......</span>
<span class=nx>postVue</span><span class=p>(</span><span class=s2>&#34;${ctx}/BusinessOpportunity/openAmlInviteAcct&#34;</span><span class=p>,</span><span class=nx>params</span><span class=p>,</span><span class=kd>function</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{......</span>

</code></pre></td></tr></table>
</div>
</div><p>这里是原有的<code>Controller</code>的实现：
<img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203911.png alt>
</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203937.png alt>
</p>
<p>然后则是<code>Service</code>的实现：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204019.png alt>
</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204039.png alt>
</p>
<p>然后就是<code>Service</code>调用不同的<code>MyBatis</code>的<code>dao</code>层实现。</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204102.png alt>
</p>
<p>从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。</p>
<h3 id=重构过程>重构过程<a hidden class=anchor aria-hidden=true href=#重构过程>#</a></h3>
<p>这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：</p>
<ol>
<li>尽可能的代码复用</li>
<li>为使用方提供一致的调用外观</li>
</ol>
<p>所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。</p>
<p>由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。</p>
<p>这个是REST Controller的实现：</p>
<pre tabindex=0><code>@PostMapping(&quot;/api/opportunities/batch&quot;)
public ResponseEntity&lt;?&gt; batchProcess(@RequestBody OpportunityBatchRequest request) {
	log.info(&quot;Process opportunity batch action - type: {}&quot;, request.getType());
	List&lt;String&gt; emailSendFailedList;
	try {
		businessOpportunityProcessorService.process(request);
		emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed();
	} catch (Exception e) {
		log.error(&quot;Process opportunity batch action failed, type: {}, root cause: {}&quot;, request.getType(), e);
		return WebUtil.error(e.getMessage());
	}

	String message = &quot;保存成功,以下企业发送通知失败，请检查：&quot; + String.join(&quot;, &quot;, emailSendFailedList);

	return new ResponseEntity&lt;&gt;(RestResponse.builder().status(HttpStatus.OK.value()).body(Boolean.TRUE).message(message).build(), HttpStatus.OK);
}
</code></pre><p><code>/api/opportunities</code> 这部分其实是放<code>RestController</code>类注解上的，这里只是为了说明。
另外，按照REST语义，针对不同的资源的操作，是区分GET、POST、DELETE等动词的，但是在真实的项目环境下，其实很难严格按照REST语义的，所以这里针对批处理的方式，统一使用了POST。</p>
<p>这个是<code>RequestBody</code>的部分，作为数据(schema)，<code>type</code>表述执行什么操作，<code>data</code>则是本次操作的数据部分。</p>
<pre tabindex=0><code>@Data
@ToString
public class OpportunityBatchRequest {
    private String type;
    private List&lt;RequestData&gt; data;

    @Data
    public static class RequestData {
        private String companyName;
        private String contactNumber;
        private Integer customerId;
        private String email;
        private String opportunityId;
    }
}
</code></pre><p>这部分就是针对批处理操作的Controller层，下面则是Service层，由于在上面已经给出了UML类图，所以这里主要是给出一些具体的实现：</p>
<p>首先是定义接口，用以规范行为，这边的泛型其实并没有实际的意义，直接就是<code>OpportunityBatchRequest </code>这个类</p>
<pre tabindex=0><code>public interface OpportunityProcessor&lt;T&gt; {
    boolean supports(String type);
    void process(T request) throws ProcessException;
}
</code></pre><p>主要是两个方法：</p>
<ul>
<li>supports：用以在具体的实现类中表达支持哪种<code>type</code>的处理</li>
<li>process： 业务处理方法</li>
</ul>
<p>具体的子类的实现示例如下：</p>
<pre tabindex=0><code>/**
 * 开通反洗钱
 */
@Service
@Slf4j
public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlAccount&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlAccount action&quot;);

    }
}
</code></pre><pre tabindex=0><code>/**
 * 开通反洗钱邀请
 */
@Service
@Slf4j
public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlInviteAccount&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlInviteAccount action&quot;);

    }
}
</code></pre><p>这里的抽象父类<code>AbstractOpportunityProcessor</code>，用以处理一些较为公共的逻辑等，比如注入公共组件，抽些公共的方法等。引入这个抽象类的性价比是很高的。</p>
<h3 id=重构后的代码>重构后的代码<a hidden class=anchor aria-hidden=true href=#重构后的代码>#</a></h3>
<p>这个例子中，有几个操作都是开通账号、邀请相关的，所以，涉及开通账号方法，就可以放在这个抽象父类中，而相应的子类，则只需要说明账户类型，就可以了：</p>
<pre tabindex=0><code>/**
 * 开通反洗钱
 */
@Service
@Slf4j
public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlAccount&quot;;
    private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.AML;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlAccount action&quot;);

        for (OpportunityBatchRequest.RequestData requestData : request.getData()) {
            openAccount(requestData, ACCOUNT_OPEN_MODE);
        }
    }
}

/**
 * 开通反洗钱邀请
 */
@Service
@Slf4j
public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlInviteAccount&quot;;
    private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.INVITE_AML;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlInviteAccount action&quot;);

        for (OpportunityBatchRequest.RequestData requestData : request.getData()) {
            openAccount(requestData, ACCOUNT_OPEN_MODE);
        }
    }
}
</code></pre><p><img loading=lazy src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204126.png alt>
</p>
<p>而对于其他的操作，则只需要在具体自己的子类中实现，如删除:</p>
<pre tabindex=0><code>/**
 * 批量删除
 */
@Service
@Slf4j
public class DeleteOpportunitiesProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;DeleteOpportunities&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process DeleteOpportunities action&quot;);

        List&lt;String&gt; opportunityIdList = request.getData()
                .stream()
                .map(OpportunityBatchRequest.RequestData::getOpportunityId)
                .collect(Collectors.toList());
        businessOpportunityMapper.deleteOpportunitiesInBatch(opportunityIdList);
    }
}
</code></pre><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2>
<p>这是本次重构的后端部分，相应的套路（模式）也更多一些，自己也相对的更加熟悉一些。这两篇博客提到的模式，在很多场景下都可以使用。</p>
<p>谢谢阅读。</p>
<p><strong>Works，then better.</strong></p>
<p><em>(2019-02-28 发表于简书)</em></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://technotes.guru/tags/%E9%87%8D%E6%9E%84/>重构</a></li>
<li><a href=https://technotes.guru/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://technotes.guru/posts/2019/bert-as-servcie%E5%9C%A8%E5%8D%95gpu%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%B3%BB%E7%BB%9F%E5%81%9C%E9%A1%BF%E7%9A%84%E9%97%AE%E9%A2%98/>
<span class=title>« Prev Page</span>
<br>
<span>解决Bert as servcie在单GPU，单线程测试场景下无响应的问题</span>
</a>
<a class=next href=https://technotes.guru/posts/2019/refactor-the-frontend/>
<span class=title>Next Page »</span>
<br>
<span>代码重构 - 前端部分代码</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://technotes.guru/>TechNotes</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>