<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>重构 on TechNotes</title>
    <link>https://technotes.guru/tags/%E9%87%8D%E6%9E%84/</link>
    <description>Recent content in 重构 on TechNotes</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 28 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://technotes.guru/tags/%E9%87%8D%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>代码重构 - 后端部分代码</title>
      <link>https://technotes.guru/posts/2019/refactor-the-backend/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://technotes.guru/posts/2019/refactor-the-backend/</guid>
      <description>前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。
在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将后端Java代码的类图画出来： 可以发现，还是一样的套路。
代码实现 下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。
原来的实现 在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过POST请求调用后端的Controller。
1 2 postVue(&amp;#34;${ctx}/BusinessOpportunity/openAcct&amp;#34;,params,function (data) {...... postVue(&amp;#34;${ctx}/BusinessOpportunity/openAmlInviteAcct&amp;#34;,params,function (data) {...... 这里是原有的Controller的实现： 然后则是Service的实现：
然后就是Service调用不同的MyBatis的dao层实现。
从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。
重构过程 这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：
尽可能的代码复用 为使用方提供一致的调用外观 所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。
由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。
这个是REST Controller的实现：
@PostMapping(&amp;#34;/api/opportunities/batch&amp;#34;) public ResponseEntity&amp;lt;?&amp;gt; batchProcess(@RequestBody OpportunityBatchRequest request) { log.info(&amp;#34;Process opportunity batch action - type: {}&amp;#34;, request.getType()); List&amp;lt;String&amp;gt; emailSendFailedList; try { businessOpportunityProcessorService.process(request); emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed(); } catch (Exception e) { log.error(&amp;#34;Process opportunity batch action failed, type: {}, root cause: {}&amp;#34;, request.getType(), e); return WebUtil.</description>
    </item>
    
    <item>
      <title>代码重构 - 前端部分代码</title>
      <link>https://technotes.guru/posts/2019/refactor-the-frontend/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://technotes.guru/posts/2019/refactor-the-frontend/</guid>
      <description>缘起 由于工作的变动，转岗到了公司的另外一个项目里，目前的主要工作在编码方面，负责将一个原来标准的J2EE（Spring， SpringMVC，MyBatis)项目，重构成基于Restful的前后端分离的项目，后端采用Spring Boot，前端部分则采用Vue。
这里计划用两篇博客记录一下重构中的一些点，一篇为前端部分，一篇为后端部分，这篇为前端部分。 由于处在不同的职位上，所关心的内容是不同的，比如产品经理更加关心产品的功能、业务的完成度、项目经理更加关注项目的进度等，另外一方面，从代码层面来说，还是比较主观的，不同的开发人员，写出来的代码也会差别很大，所以这里仅是个人的重构记录。下面就闲话少说，“talk is cheap, show me the code”。
业务背景 这里首先交代下重构部分的业务，如下图所以，这是个比较典型的数据表格，展示了业务数据，以及相关的操作，查看详情，编辑，删除，并且可以多选，并且进行对多条数据进行批量的操作。
下图是完成了的数据表格部分，隐藏了其中涉及到的业务数据
其主要的功能为：
表格右侧的“操作”部分，主要是针对单条记录的操作，如查看，修改，删除 表格下方的批量操作部分，当选中多条记录之后，执行不同的批量操作，如批量发送邀请，批量创建账号，批量删除等。针对不同的操作，在执行相应的操作时候，需要进行不同的前端验证，如开通邀请，则需要验证所选择的记录的电话号码不能为空，邮箱不能为空，销帮帮ID是否存在，等。 代码实现 简单介绍完需求之后，逻辑并不复杂，从代码实现角度，主要就是如下几步： 1、响应按钮点击 2、在响应的方法中遍历选中的数据 3、对数据进行校验，如何校验失败，则进行相应的提示 4、将数据提交到后端
实现起来也是相当的明了。
原来的实现 这部分主要描述下上述需求的原来的实现部分，这里不会贴出全部的代码，主要还是将意图表达出来。另外，这个项目的前端展示部分是基于JSP+jQuery+Vue的，所以原来页面部分逻辑较为复杂，一部分数据是传统的基于表单的，一部分数据是jQuery Ajax方式的，一部分数据则是Vue（axios）方式。
下面的三张截图，第一张是按钮部分，针对不同的功能，对应不同的响应方法: 下面两张是其中两个方法的具体实现:
由于逻辑不复杂，所以实现上也是比较的明了。基本上完成过程式的代码实现，遍历选择的数据，对数据进行校验，然后调用后台对应的接口。
过程式的代码，优点是代码清晰明了，基本上完全反映实现的意图。缺点也比较的明显，大量的重复代码，拿贴出来的两段代码来看，基本上都是相同的，复制粘贴一个方法，然后稍微的改一改。这里不去写这些的弊端，重点还是放在重构部分的内容上。
重构过程 首先上面的代码，从功能角度来说，是可以工作的代码，但是，很多的重复代码。实际上很容易就可以发现其中可以重用的部分，如公司名称的校验，销帮帮ID的校验，邮箱的校验等。 那么，最简单的实现重用的方式，可以将其中的检验部分抽出来，形成一个一个单独的验证方法，如：
validateEmailXXX() validateCompanyNameXXX() 这样在不同的方法中，就可以重用这些验证的逻辑，原来代码中的isEmailAvailable()方法就是工具方法层面的复用。比如说常见的代码中的很多的工具类，如StringUtils，DateUtils，就是这样的一个思路，实现了一些工具方法层面的重用。(对于Ruby，Kotlin，可以非常优雅的扩展父类方法)。
不过这部分重构，我并非仅仅是抽取了几个验证的方法。下面会描述，这里先说一下我考虑的两个原则：
为使用方提供一致的调用外观 尽可能的代码复用 提供较为一致的调用外观 这部分主要是真的按钮的响应，所以这里统一了方法handleOperation的调用，然后通过type来区分。这部分看个人的习惯了，比如原来的方式，也是不错的，方法名就反映出来该方法的意图。
&amp;lt;el-button type=&amp;#34;primary&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;openAmlAccount&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;开通反洗钱&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;primary&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;openAmlInviteAccount&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;开通反洗钱邀请账号&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;danger&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;deleteOpportunities&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;批量删除&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;primary&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;openNormalAccount&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;开通账号&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;primary&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;openInviteAccount&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;开通邀请账号&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;danger&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;physicallyDelete&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;删除账号&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&amp;#34;danger&amp;#34; :disabled=&amp;#34;totalSelectedRows === 0&amp;#34; @click=&amp;#34;handleOperation(&amp;#39;completelyPhysicalDelete&amp;#39;)&amp;#34;&amp;gt;&amp;lt;span&amp;gt;彻底删除&amp;lt;/span&amp;gt;&amp;lt;/el-button&amp;gt; handleOperation则根据不同的type，分别调用相对于的处理方法。</description>
    </item>
    
  </channel>
</rss>
