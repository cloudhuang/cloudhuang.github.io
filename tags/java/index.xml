<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on TechNotes</title>
    <link>https://technotes.guru/tags/java/</link>
    <description>Recent content in Java on TechNotes</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 21 Jun 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://technotes.guru/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Running Spring Batch on Multiple Databases in Parallel</title>
      <link>https://technotes.guru/posts/2017/running-spring-batch-on-multiple-databases-in-parallel/</link>
      <pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://technotes.guru/posts/2017/running-spring-batch-on-multiple-databases-in-parallel/</guid>
      <description>The Question I&amp;rsquo;ve created a Spring batch application using Spring boot, and I have a Job with 9 steps. These steps are using a DataSource which I created its bean in a configuration file as follows:
@Configuration public class DatabaseConfig { @ConfigurationProperties(prefix = &amp;quot;spring.datasource&amp;quot;) @Bean @Primary public DataSource dataSource(){ return DataSourceBuilder.create().build(); } }  This DataSource is using properties declared in the application.yml file:
spring: datasource: url: jdbc:mysql://localhost:3306/db_01?zeroDateTimeBehavior=convertToNull username: xxxx password: ****  So far, all works as expected.</description>
    </item>
    
    <item>
      <title>Generic Data Access Objects －范型DAO类设计模式</title>
      <link>https://technotes.guru/posts/2007/the-generic-dao/</link>
      <pubDate>Thu, 19 Apr 2007 00:00:00 +0000</pubDate>
      
      <guid>https://technotes.guru/posts/2007/the-generic-dao/</guid>
      <description>Generic Data Access Objects －范型DAO类设计模式, DAO模式是最为经典的JAVA EE模式之一, 特别是自JDK5之后增加的泛型支持，大大增加了DAO的可复用性。(发布于JavaEye)
 普通数据访问对象，这个是Hibernate官方网站上面的一个DAO类的设计模式，基于JDK5.0范型支持,文章地址如下：
 Generic Data Access Objects 
我下面的代码与Hibernate官网上提供的有点不同。 首先定义DAO类的接口IGenericDAO，该接口定义了共同的CRUD操作：
/** * 定义通用的CRUD操作 */ public interface IGenericDAO &amp;lt;T, ID extends Serializable&amp;gt; { // 通过主键标识查找某个对象。 public T findById(ID id); // 通过主键标识查找某个对象，可以锁定表中对应的记录。 T findById(ID id, boolean lock); // 得到所有的对象。 List&amp;lt;T&amp;gt; findAll(); // 通过给定的一个对象，查找与其匹配的对象。 List&amp;lt;T&amp;gt; findByExample(T exampleInstance); // 持久化对象。 T makePersistent(T entity); // 删除对象。 void makeTransient(T entity); } 下面是使用Hibernate针对该接口的实现GenericDAOHibernate:
/** * 这是针对IGenericDAO接口的Hibernate实现，完成通用的CRUD操作。 * @param T POJO类 * @param ID POJO类的主键标识符 * @param DAOImpl 针对每一个POJO类的DAO类实现 */ public abstract class GenericDAOHibernate &amp;lt;T,ID extends Serializable, DAOImpl extends IGenericDAO&amp;lt;T, ID&amp;gt;&amp;gt; implements IGenericDAO&amp;lt;T,ID&amp;gt; { private Class&amp;lt;T&amp;gt; persistentClass; protected Session session; public GenericDAOHibernate() { this.</description>
    </item>
    
  </channel>
</rss>
