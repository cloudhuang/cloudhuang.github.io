<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>单元测试 on TechNotes</title>
    <link>https://technotes.guru/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
    <description>Recent content in 单元测试 on TechNotes</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 20 Aug 2009 00:00:00 +0000</lastBuildDate><atom:link href="https://technotes.guru/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一个小项目的回顾</title>
      <link>https://technotes.guru/posts/2009/a-project-retrospection/</link>
      <pubDate>Thu, 20 Aug 2009 00:00:00 +0000</pubDate>
      
      <guid>https://technotes.guru/posts/2009/a-project-retrospection/</guid>
      <description>最近的一个项目，四个开发人员，大概做了一个月多一点，从需求，到最终代码的完成。
写思考，我想，主要还是要回顾一下在项目中遇到的问题，或是有什么比较好的经验，新的体会值得记录下来，以供以后参考。在这里，主要是要思考两个方面的问题，数据库和测试。
  数据库
对于数据库，在j道上面有这样一篇文章 《数据库已死》 ，其主要思想，个人感觉，主要还是对象与关系的问题，我们现在的主流已经是面向对象，但现在，可能很多公司仍以数据库建模作为其一条主线，首先进行数据建模，erwin，powerdesigner(后注: 实际上PowerDesigner的Logical Data Model的设计非常的强大，可以首先设计Logical Data Model, 然后转换成Physical Data Model，最后生成DDL)，然后创建相应的表，下面，就使用myeclipse,hibernate tools等生成相应的实体类，以及相应的映射文件。包括以前的几个项目，者是在开始花了大量的时间进行数据库的设计，中途加入的项目，也会在进入项目组的开始阶段让你熟悉其数据库的表结构，当面对大量的表的时候，看着E-R图上面的“蜘蛛网”的时候，可能，就已经晕了。
实际上，在面向对象的时代，数据库只是状态持久化的一种手段，数据库的表结构完全可以通过Hibernate等ORM工具自动生成。
在这个小项目中，前期，并没有花大多的时候在数据库的设计上，在初期建模了一些核心对象，创建相应的实体类，加上相应的注解，借助于hibernate的hbm2ddl，完全可以由hibernate自动生成相应的表结构。当增加新的对象的时候，也只需要定义其类结构。
并且，可以提供不同的sessionfactory，分别针对测试等环境，也可以做到一定程度的database migration。
  测试
TDD，BDD，持续集成~~~~等等，不知道有多少公司实施了，并且实施的情况如何。在以前的项目中，最怕的，就是测试数据依赖于其它的模块，当跑一次测试，还需要去跑一下由其它小组开发的模块，当对该模块的业务不太了解的时候，测试起来，还是比较麻烦的，还有可能需要麻烦其它小组的人员来为我们提供相应的测试数据。
这种情况，其中一个原因，测试代码太少。所以在这个项目中，针对一些核心的，或是较复杂的业务逻辑，都提供了相应的测试代码(当然，这里有一个粒度的问题)，虽然在开发过程中，需要抽出一部分时间来编写相应的测试代码，但在实际过程中，效果还是比较明显的。
  </description>
    </item>
    
  </channel>
</rss>
